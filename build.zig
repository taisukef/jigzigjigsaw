const std = @import("std");

// この関数は命令形に見えますが、ビルドを直接実行するのではなく、
// 外部ランナーによって実行されるビルドグラフ（`b`）を変更します。
// `std.Build`の関数は、ビルドステップを定義し、それらの間の依存関係を表現するための
// DSLを実装しており、ビルドランナーが自動的にビルドを並列化できるようにします
// （また、キャッシュシステムがステップを再実行する必要がないことを認識できるようにします）。
pub fn build(b: *std.Build) void {
    // 標準のターゲットオプションを使用すると、`zig build`を実行する人が
    // ビルド対象のターゲットを選択できます。ここではデフォルトを上書きしていないため、
    // 任意のターゲットが許可され、デフォルトはネイティブになります。
    // サポートされるターゲットセットを制限するための他のオプションも利用可能です。
    const target = b.standardTargetOptions(.{});
    // 標準の最適化オプションを使用すると、`zig build`を実行する人が
    // Debug、ReleaseSafe、ReleaseFast、ReleaseSmallの中から選択できます。
    // ここでは推奨されるリリースモードを設定せず、ユーザーが最適化方法を決定できるようにしています。
    const optimize = b.standardOptimizeOption(.{});
    // `b.option()`を使用して、このビルドスクリプトのオプション機能を切り替えるための
    // カスタムフラグをさらに定義することも可能です。定義されたすべてのフラグ
    // （ターゲットおよび最適化オプションを含む）は、このディレクトリで`zig build --help`を
    // 実行すると一覧表示されます。

    // これはモジュールを作成します。モジュールとは、ソースファイルのコレクションと、
    // 最適化モードやリンクされたシステムライブラリなどのコンパイルオプションを表すものです。
    // Zigモジュールは、Zigコードを利用者に提供するための推奨される方法です。
    // addModuleは、利用者がインポートできるようにすることを意図したモジュールを定義します。
    // Zigパッケージは複数のモジュールを公開でき、利用者はアクセスしたいモジュールを
    // 指定する必要があるため、名前を付ける必要があります。
    const mod = b.addModule("jigzigjigsaw", .{
        // ルートソースファイルはこのモジュールの「エントリポイント」です。
        // このモジュールのユーザーは、このファイルに含まれるパブリックな宣言にのみアクセスできます。
        // つまり、このモジュールの一部である他のファイルで定義された宣言を利用者に公開したい場合は、
        // 必ずルートファイルからそれらを再エクスポートする必要があります。
        .root_source_file = b.path("src/root.zig"),
        // 後でこのモジュールをテスト実行ファイルのルートモジュールとして使用するため、
        // ターゲットを指定する必要があります。
        .target = target,
    });

    // ここでは実行可能ファイルを定義します。実行可能ファイルには、`main`関数を公開する
    // ルートモジュールが必要です。上で定義したモジュールにmain関数を追加することもできますが、
    // ビジネスロジックとCLIを2つの別々のモジュールに分割する方が好ましい場合があります。
    //
    // 他の人が使用するためのZigライブラリを作成することが目的の場合、
    // CLIツールも公開すると有益かどうか検討してください。例えば、データシリアライズ形式の
    // パーサーライブラリには、CLI構文チェッカーを同梱できるかもしれません。
    //
    // 代わりに実行可能ファイルを作成することが目的の場合、CLIツールのサブプロセス化に伴う
    // オーバーヘッドを回避するために、ユーザーがあなたのプログラムのコア機能を
    // 独自の実行可能ファイルに埋め込むことに関心があるかどうか検討してください。
    //
    // どちらの場合も当てはまらない場合は、不要な宣言を自由に削除し、
    // すべてを単一のモジュールにまとめてください。
    const exe = b.addExecutable(.{
        .name = "jigzigjigsaw",
        .root_module = b.createModule(.{
            // b.createModuleはb.addModuleと同様に新しいモジュールを定義しますが、
            // b.addModuleとは異なり、このパッケージの利用者にモジュールを公開しません。
            // そのため、この場合は名前を付ける必要がありません。
            .root_source_file = b.path("src/main.zig"),
            // ターゲットと最適化レベルは、実行可能ファイルまたはライブラリを定義する際
            // （ルートモジュール内）に明示的に接続する必要があります。また、必要であれば
            // （例：組み込みデバイス用のファームウェアなど）、実行可能ファイルまたは
            // ライブラリ定義に対して特定のターゲットをハードコードすることもできます。
            .target = target,
            .optimize = optimize,
            // ルートモジュールの一部であるソースファイルでインポート可能なモジュールのリスト。
            .imports = &.{
                // ここでの "jigzigjigsaw" は、このモジュールをインポートするためにソースコードで
                // 使用する名前です（例：`@import("jigzigjigsaw")`）。インポートの名前を
                // 変更することは許可されており、衝突（異なるパッケージからモジュールを
                // インポートする場合に発生する可能性があります）の場合に非常に役立つため、
                // 名前が繰り返されています。
                .{ .name = "jigzigjigsaw", .module = mod },
            },
        }),
    });

    // これは、`zig build`を実行した際（つまり、デフォルトのステップを実行した際）に、
    // 実行可能ファイルをインストールプレフィックスにインストールする意図を宣言します。
    // デフォルトではインストールプレフィックスは `zig-out/` ですが、
    // `--prefix` または `-p` を渡すことで上書きできます。
    b.installArtifact(exe);

    // これはトップレベルのステップを作成します。トップレベルのステップには名前があり、
    // `zig build`を実行するときに名前で呼び出すことができます（例：`zig build run`）。
    // これにより、デフォルトのステップではなく `run` ステップが評価されます。
    // トップレベルのステップが実際に何かを行うには、他のステップ
    // （この後すぐに説明するRunステップなど）に依存する必要があります。
    const run_step = b.step("run", "Run the app");

    // これはビルドグラフにRunArtifactステップを作成します。RunArtifactステップは、
    // Zigによってコンパイルされた実行可能ファイルを呼び出します。ステップは、
    // ユーザーによって直接呼び出された場合（トップレベルのステップの場合）、
    // または別のステップがそれに依存している場合にのみ、ランナーによって実行されます。
    // したがって、このRunステップをいつどのように実行するかを定義するのはあなた次第です。
    // このケースでは、ユーザーが `zig build run` を実行したときに実行したいため、
    // 依存関係のリンクを作成します。
    const run_cmd = b.addRunArtifact(exe);
    run_step.dependOn(&run_cmd.step);

    // runステップをデフォルトステップに依存させることで、キャッシュディレクトリ内から
    // 直接実行されるのではなく、インストールディレクトリから実行されるようになります。
    run_cmd.step.dependOn(b.getInstallStep());

    // これにより、ユーザーは次のようにビルドコマンド自体でアプリケーションに引数を
    // 渡すことができます：`zig build run -- arg1 arg2 etc`
    if (b.args) |args| {
        run_cmd.addArgs(args);
    }

    // 提供されたモジュールの `test` ブロックを実行する実行可能ファイルを作成します。
    // ここで `mod` はターゲットを定義する必要があるため、先ほど相対フィールドを
    // 確実に設定しました。
    const mod_tests = b.addTest(.{
        .root_module = mod,
    });

    // テスト実行可能ファイルを実行するrunステップ。
    const run_mod_tests = b.addRunArtifact(mod_tests);

    // 実行可能ファイルのルートモジュールの `test` ブロックを実行する実行可能ファイルを作成します。
    // テスト実行可能ファイルは一度に1つのモジュールしかテストしないため、
    // 2つの別々の実行可能ファイルを作成する必要があります。
    const exe_tests = b.addTest(.{
        .root_module = exe.root_module,
    });

    // 2番目のテスト実行可能ファイルを実行するrunステップ。
    const run_exe_tests = b.addRunArtifact(exe_tests);

    // すべてのテストを実行するためのトップレベルステップ。dependOnは複数回呼び出すことができ、
    // 2つのrunステップは互いに依存していないため、これらは並列に実行されます。
    const test_step = b.step("test", "Run tests");
    test_step.dependOn(&run_mod_tests.step);
    test_step.dependOn(&run_exe_tests.step);

    // フラグと同様に、トップレベルのステップも `--help` メニューに表示されます。
    //
    // Zigビルドシステムは完全にユーザーランドで実装されています。つまり、
    // プライベートなコンパイラAPIにフックすることはできません。ビルドシステムによって
    // 調整されるすべてのコンパイル作業は、正しいフラグが定義された状態で呼び出される
    // 他のZigコンパイラサブコマンドという結果になります。失敗したとき
    // （または冗長性を高めるためにフラグを渡したとき）にこれらの呼び出しを観察して、
    // 仮定を検証し、問題を診断できます。
    //
    // 最後に、Zigビルドシステムは比較的シンプルで自己完結しており、
    // そのソースコードを読むことで習得することができます。
}
